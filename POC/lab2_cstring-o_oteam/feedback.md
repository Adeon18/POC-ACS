# The Lab Feedback

Це є файл-фідбек до лабораторної роботи з всіма "цікавими рішеннями", які ми змогли знайти тут.
Також це файл містить загальний фідбек до читабельності функцій та зручності використання бібліотеки загалом.

## Якість пакету та коду

У пакеті наявні описи(документація) до кожної функції та присутні коментарі до кусків коду, які цього потребують. У загальному, код читається доволі легко, за вийнятком деяких функцій(які написані нижче). Поділ на .h та .c файли присутній та CMakeLists.txt зручний для використання.

## Якість реалізації

Майже всі функції працюють коректно і не падають, але для успішного виконяння лабораторної нам довелося підправити функцію **my_str_find_if**(Саме як написано нижче) і також функція **my_str_read_file_delim** для одного з випадків видає Segmentation fault(Про це також нижче).

## Зауваження до реалізацій

Тут будуть наведені всі зауваження до реалізації функцій та частини функцій які привернули нашу увагу.

- my_str_get_cstr не повертає новий c_string, а повертає:
```
return str->data;
```
Що не задовільняє умову:
```
/*
 * returns c-string with the same content as my_str-string
 * result c-string is constant and can be incorrect after changing my_str content
 * returns NULL if str is NULL
 */
```

- У my_str_insert цікава реалізація, відбувається конвертація from у cstr і викликається my_str_insert_cstr. Аналогічну реалізацію можна побачити у my_str_cmp та my_str_cmp_cstr.

- my_str_insert_c має виклик my_str_append_c який додає 'i' для того щоб збільшити size_m. Це доволі дивний спосіб, враховуючи що потім зразу викликається перевірка на помилки в append_с.

- Коли у my_str_append_c передається пуста стрічка, виділяється комірка розміром 0:
```
int err = my_str_reserve(str, str->capacity_m * 2);
```
Де str->capacity_m * 2 = 0 * 2 = 0.

- В my_str_find_if відбувається перевірка 
```
if (predicat((int)str->data[i]) == 1)
```
Ця перевірка не є робочою для, наприклад, функції isspace(), адже вона для правдивих випадків повертає НЕНУЛЬОВЕ значення, але це не є строго 1. Це можна виправити ось так:
```
if (predicat((int)str->data[i]))
```
- В my_str_erase відбувається виклик:
```
my_str_reserve(str, str->capacity_m - erase_seg);
```
Оскільки str->capacity_m - erase_seg є меншим або рівним за capacity_m, ця функція абсолютно нічого не робить і повертає 0(Така реалізація my_str_reserve).

- Цікава реалізація my_str_reserve, замість того щоб виділити новий кусок динамічної пам'яті і туди все перекопіювати ми створюємо новий my_str_t, туди все перекопійовуємо, потім чистимо попередню стрічку та переміщуємо в неї дані з my_str_t. Також не побачив щоб виділявся розмір пам'яті + 1 для кінцевого символу в функції(У інших функціях в неї не передають розмір бажаної комірки + 1).
- Аналогічна реалізація спостерігається  в my_str_shrink_to_fit.

- my_str_read_file_delim повертає segmentation fault коли делімітер не знайдений.

## Оцінка

Ми вирішили поставити цій команді **8/10** адже усі крім двох функці1 працюють добре. Також є невеличкі питання до реалізації деяких функцій.
